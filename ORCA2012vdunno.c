#pragma config(Sensor, S1,     ,               sensorEV3_Color)
#pragma config(Sensor, S4,     ,               sensorEV3_Color)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define FIELDX 120.5
#define FIELDY 120
#define SPEED 60
#define FINT 70
#define OINT 10
#define FAVG 50
#define WMAX 120
#define HMAX 120
#define OUT 0
#define IN 1

#define WHEEL 18
#define AXLE 11

#define ALTS(A) ((A)==0 ? 3 : 0)
#define MEDIAN(a,b,c) ((a-b)*(b-c) > 1 ? b : ((a-b)*(a-c) < -1 ? a : c))

int totalDist;
int ACTUALRADIUS;

void moveRob(float distance, int speed);
void rotateRob(float angle, int speed);
void edgeRob(int speed, int sensor, int no);
//bool analyzeArray(int flag);
bool posRob(int sensor, int inOrOut);
//void clearMem();
void encircle();
void align();
void inputValue();
void pushOff();
void checkList();

void inputValue(){
	int i,k;
	sleep(1000);
	for(i = 1; i < 6; i++){
		if(getButtonPress(i) == 1){
			break;
		}
		if(i==5){
			i=0;
		}
	}
	ACTUALRADIUS = (i)*10;
	sleep(600);
	for(k = 1; k < 3; k++){
		if(getButtonPress(k) == 1){
			break;
		}
		if(k==2){
			k=0;
		}
	}
	k--;
	ACTUALRADIUS += k*5;
	displayCenteredBigTextLine(2, " %d", ACTUALRADIUS);
}

task main(){
	checkList();
	inputValue();
	ACTUALRADIUS=ACTUALRADIUS+4+AXLE/2;
	setMotorSpeed(motorA,0);

	for(int i = 0; i < 4; i++){
		resetMotorEncoder(motorA);
		edgeRob(SPEED,S4,i);
		if(i!=3){
			moveRob(7,SPEED);
			sleep(300);
			moveRob(-4,SPEED);
			setMotorSpeed(motorA,0);
			setMotorSpeed(motorB,0);
			sleep(500);
			rotateRob(-90,SPEED);
		}
		sleep(200);
	}
	rotateRob(-90,40);
	moveRob(-13,SPEED);
	align();
	moveRob(FIELDX/2-ACTUALRADIUS+10,SPEED);
	rotateRob(90,SPEED);
	encircle();

	//following code aligns to hit the ball
	moveRob(-(FIELDY/2),SPEED);
	rotateRob(-90,SPEED);
	moveRob(-((FIELDX/2)-ACTUALRADIUS+11+4)+7,SPEED);
	align();
	moveRob(14,SPEED);
	rotateRob(90,SPEED);
	edgeRob(SPEED,S4,1);
	setMotorSpeed(motorA,0);
	setMotorSpeed(motorD,0);
	sleep(100);
	moveRob(-7,SPEED);
	rotateRob(-90,SPEED);
	moveRob(-10,SPEED);
	align();
	moveRob(((FIELDX/2)+11+9),60);
	setMotorSpeed(motorC,-10);
	rotateRob(-90,SPEED);
	moveRob(-13-5,SPEED);
	setMotorSpeed(motorC,-10);
	align();
	rotateRob(180,SPEED);
	moveRob(-14-11-1, SPEED*2);
	setMotorSpeed(motorC,100);
	sleep(500);
	setMotorSpeed(motorC,0);
	moveRob(-(-((FIELDY/2)-32)-11),50);
	rotateRob(180,SPEED);
	align();
	moveRob(17,SPEED);
	rotateRob(-90,SPEED);
	edgeRob(SPEED,S1,1);

}

void moveRob(float distance, int speed){
	int encoder[2];
	encoder[0] = getMotorEncoder(motorA);
	encoder[1] = getMotorEncoder(motorD);
	setMotorSpeed(motorA,speed*sgn(distance));
	setMotorSpeed(motorD,speed*sgn(distance));
	distance = distance * (360 / WHEEL);
	encoder[0] += distance;
	encoder[1] += distance;
	int flag = sgn(encoder[0]-getMotorEncoder(motorA));
	while(flag+sgn(encoder[0]-getMotorEncoder(motorA)) && flag+sgn(encoder[1]-getMotorEncoder(motorD))){}
	setMotorSpeed(motorA,0);
	setMotorSpeed(motorD,0);
	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);
}

void rotateRob(float angle, int speed){
	int encoder[2];
	encoder[0] = getMotorEncoder(motorA);
	encoder[1] = getMotorEncoder(motorD);
	setMotorSpeed(motorA,speed*sgn(angle));
	setMotorSpeed(motorD,speed*-sgn(angle));
	float distance = angle * (AXLE * PI * (360.0 / WHEEL)) / 360.0;
	encoder[0] += distance;
	encoder[1] -= distance;
	int flag[2];
	flag[0] = sgn(encoder[0]-getMotorEncoder(motorA));
	flag[1] = sgn(encoder[1]-getMotorEncoder(motorA));
	while(flag[0]+sgn(encoder[0]-getMotorEncoder(motorA)) && flag[1]+sgn(encoder[1]-getMotorEncoder(motorB))){}
	setMotorSpeed(motorA,0);
	setMotorSpeed(motorD,0);
}

void edgeRob(int speed , int sensor, int no){
	resetMotorEncoder(motorA);
	float distance = FIELDY/2;
	float limit = (FIELDY/2)>(FIELDX/2) ? (FIELDX/2) : (FIELDY/2);
	distance = distance * (360 / WHEEL);
	limit = limit * (360 / WHEEL);
	while(posRob(ALTS(sensor),IN)){
		while(posRob(ALTS(sensor),IN)){
			if(sensor){
				setMotorSpeed(motorA,speed-.3*(FAVG-getColorReflected(sensor)));
				setMotorSpeed(motorD,speed+.4*(FAVG-getColorReflected(sensor)));
				}else{
				setMotorSpeed(motorA,speed+.3*(FAVG-getColorReflected(sensor)));
				setMotorSpeed(motorD,speed-.4*(FAVG-getColorReflected(sensor)));
			}
			if(no == 3){
				displayBigTextLine(2, "%d", getMotorEncoder(motorA));
				if(getMotorEncoder(motorA)>distance){
					setMotorSpeed(motorA,0);
					setMotorSpeed(motorD,0);
					return;
				}
			}
			sleep(30);
		}
		sleep(30);
	}
}

bool posRob(int sensor, int inOrOut){
	if(getColorReflected(sensor)<OINT){
		return(OUT==inOrOut);
		}else if(getColorReflected(sensor)>OINT){
		return(IN==inOrOut);
	}
	return false;
}

void encircle(){
	setMotorSpeed(motorD,40);
	setMotorSpeed(motorA,40*(ACTUALRADIUS-AXLE/2)/(ACTUALRADIUS+AXLE/2));
	resetMotorEncoder(motorD);
	totalDist = getMotorEncoder(motorD);
	pushOff();
	pushOff();
	while(getMotorEncoder(motorD)<=(ACTUALRADIUS+AXLE/2)*2*PI*1.1*(360/WHEEL));
	int temp = getMotorEncoder(motorA);
	while(getColorReflected(S1)>FAVG || getColorReflected(S4)>FAVG){
		setMotorSpeed(motorA,50);
		setMotorSpeed(motorD,50);
	}
	sleep(500);
	setMotorSpeed(motorA,0);
	setMotorSpeed(motorD,0);
	sleep(50);
	while(getMotorEncoder(motorA)>temp){
		setMotorSpeed(motorA,-50);
		setMotorSpeed(motorD,-50);
	}
	setMotorSpeed(motorA,0);
	setMotorSpeed(motorD,0);
}

void align(){
	time1[T1] = 0;
	while(time1[T1]<=1000){
		setMotorSpeed(motorA,(FAVG-getColorReflected(S1))/3);
		setMotorSpeed(motorD,(FAVG-getColorReflected(S4))/3);
	}
}

void pushOff(){
	int temp;
	while(getMotorEncoder(motorD)<=(ACTUALRADIUS+AXLE/2)*2*PI*1.1*(360/WHEEL)){
		if(getUSDistance(S2)<15){
			temp = getMotorEncoder(motorA);
			while(getColorReflected(S1)>FAVG || getColorReflected(S4)>FAVG){
				setMotorSpeed(motorA,50);
				setMotorSpeed(motorD,50);
			}
			sleep(500);
			setMotorSpeed(motorA,0);
			setMotorSpeed(motorD,0);
			sleep(50);
			while(getMotorEncoder(motorA)>temp){
				setMotorSpeed(motorA,-50);
				setMotorSpeed(motorD,-50);
			}
			setMotorSpeed(motorA,0);
			setMotorSpeed(motorD,0);
			setMotorSpeed(motorD,40);
			setMotorSpeed(motorA,40*(ACTUALRADIUS-AXLE/2)/(ACTUALRADIUS+AXLE/2));
			break;
		}
	}
}

void checkList(){
	getMotorEncoder(motorA);
	getMotorEncoder(motorC);
	getMotorEncoder(motorD);
	getColorReflected(S1);
	getColorReflected(S4);
	getUSDistance(S2);
	playSound(soundBeepBeep);
}


/*
void clearMem(){
for(int i = 0;i < 500; i++){
distance[i] = 0;
}
}
*/
